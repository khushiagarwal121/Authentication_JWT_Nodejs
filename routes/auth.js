const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = require("../models/user");
const { body, validationResult } = require("express-validator");

const router = express.Router();
const jwtSecret = process.env.JWT_SECRET;
const jwtExpiry = "1h";
const refreshTokenExpiry = "7d";

const generateToken = (userId, expiry) => {
  return jwt.sign({ userId }, jwtSecret, { expiresIn: expiry });
};

router.post("/register", async (req, res) => {
  const { username, password } = req.body;

  try {
    // User is a model with these crud operations method
    let user = await User.findOne({ username });
    if (user) {
      return res.status(400).json({ msg: "User already exists" });
    }
    // new instance of model created
    // A new instance of a model created in frameworks or libraries is often called a document or object.
    user = new User({ username, password });
    // A salt is a random value added to the password before hashing. Its main purpose is to ensure that even if two users have the same password, their hashed passwords will be different because each one will have a unique salt. This helps protect against precomputed attacks, like rainbow table attacks, where attackers use precomputed hash values to crack passwords.
    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(password, salt);

    await user.save();
    res.json({ msg: "user registered successfully" });
  } catch (err) {
    console.error(err.message);
    res.status(500).send("server error");
  }
});

router.post("/login", async (req, res) => {
  const { username, password } = req.body;

  try {
    const user = await User.findOne({ username });
    if (!user) {
      return res.status(400).json({
        msg: "Invalid credentials",
      });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ msg: "invalid credentials" });
    }
    //     { userId: user._id }: This is the content of the payload object:

    // userId: This is a key in the payload object.
    // user._id: This is the value assigned to the userId key. Here, user._id refers to the unique identifier (ID) of the user, which is generated by MongoDB and stored in the user document.

    // const token = jwt.sign(payload, secretkey, { expiresIn: "1h" });
    const accessToken = generateToken(user.id, jwtExpiry);
    const refreshToken = generateToken(user.id, refreshTokenExpiry);

    res.json({ accessToken, refreshToken });
  } catch (err) {
    console.error(err.message);
    res.status(500).send("server error");
  }
});

router.post("/refresh-token", (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken)
    return res.status(401).json({ msg: "no refresh token provided" });
  try {
    const decoded = jwt.verify(refreshToken, jwtSecret);
    const newAccessToken = generateToken(decoded.userId, jwtExpiry);
    res.json({ accessToken: newAccessToken });
  } catch (err) {
    res.status(401).json({ msg: "Invalid refresh token" });
  }
});

router.get("/protected", (req, res) => {
  const token = req.header("x-auth-token");
  if (!token) {
    return res.status(401).json({ msg: "No token,authorization denied" });
  }

  try {
    const decoded = jwt.verify(token, jwtSecret);
    req.user = decoded.userId;
    res.json({ msg: "Access granted", userid: req.user });
  } catch (err) {
    res.status(401).json({ msg: "Invalid token" });
  }
});

module.exports = router;
